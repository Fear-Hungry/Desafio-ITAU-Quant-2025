"""Utilities that assemble performance reports from metrics and figures."""

from __future__ import annotations

import base64
from dataclasses import dataclass, field
from io import BytesIO
from pathlib import Path
from string import Template
from typing import Any, Iterable, Mapping, Sequence, Tuple, Union

import matplotlib.pyplot as plt
import pandas as pd

from itau_quant.risk.budgets import RiskBudget

from .plots import TearsheetFigure, plot_cumulative_returns, plot_drawdown
from .stats import RiskContributionResult, RiskSummary

FigureLike = Union[plt.Figure, TearsheetFigure, Tuple[str, plt.Figure]]


@dataclass(frozen=True)
class ReportBundle:
    """Normalised container with all artefacts required to build a report."""

    performance: pd.DataFrame
    risk: pd.DataFrame
    drawdowns: pd.DataFrame | None
    figures: list[tuple[str, plt.Figure]]
    metadata: dict[str, Any]
    returns: pd.DataFrame | None = None
    benchmark: pd.DataFrame | None = None
    risk_contribution: RiskContributionResult | None = None
    risk_budgets: dict[str, list[str]] | None = None
    cost_breakdown: pd.DataFrame | None = None


@dataclass(frozen=True)
class ReportArtifacts:
    """Files generated by :func:`build_and_export_report`."""

    bundle: ReportBundle
    html_path: Path
    pdf_path: Path
    table_paths: dict[str, Path] = field(default_factory=dict)


@dataclass(frozen=True)
class AdvancedTearsheetData:
    """Inputs required to build the advanced tear sheet figures."""

    returns: pd.Series | pd.DataFrame | None = None
    benchmark: pd.Series | pd.DataFrame | None = None
    nav: pd.Series | pd.DataFrame | None = None
    risk_budgets: Sequence[RiskBudget] | None = None
    cost_breakdown: pd.Series | pd.DataFrame | Mapping[str, float] | None = None
    nav_title: str = "Cumulative NAV"
    drawdown_title: str = "Drawdown"
    risk_budget_title: str = "Risk Contribution by Budget"
    cost_title: str = "Cost Decomposition"
    cost_label: str = "Cost"


def _normalise_figures(figures: Iterable[FigureLike]) -> list[tuple[str, plt.Figure]]:
    normalised: list[tuple[str, plt.Figure]] = []

    for item in figures:
        if isinstance(item, TearsheetFigure):
            normalised.append((item.title, item.figure))
        elif isinstance(item, tuple) and len(item) == 2:
            title, figure = item
            if not isinstance(figure, plt.Figure):
                raise TypeError("Tuple entries must be (title, Figure)")
            normalised.append((str(title), figure))
        elif isinstance(item, plt.Figure):
            normalised.append(("Figure", item))
        else:
            raise TypeError(f"Unsupported figure format: {item!r}")
    return normalised


def _coerce_frame(
    data: pd.Series | pd.DataFrame | None,
    *,
    name: str,
) -> pd.DataFrame | None:
    """Convert optional series/frames into a clean DataFrame."""

    if data is None:
        return None
    if isinstance(data, pd.DataFrame):
        frame = data.copy()
    elif isinstance(data, pd.Series):
        frame = data.to_frame(name=data.name or name)
    else:
        raise TypeError(f"{name} must be a pandas Series or DataFrame when provided.")

    frame = frame.apply(pd.to_numeric, errors="coerce").dropna(how="all")
    if frame.empty:
        return None
    return frame


def _normalise_risk_budgets(
    budgets: Mapping[str, Sequence[str]] | Sequence[Any] | None
) -> dict[str, list[str]] | None:
    """Convert different budget specifications into a {name: [tickers]} mapping."""

    if budgets is None:
        return None

    if isinstance(budgets, Mapping):
        return {
            str(name): [str(ticker) for ticker in sequence if str(ticker)]
            for name, sequence in budgets.items()
        }

    mapping: dict[str, list[str]] = {}
    for item in budgets:
        if isinstance(item, RiskBudget):
            mapping[item.name] = [str(ticker) for ticker in item.tickers if str(ticker)]
        elif isinstance(item, Mapping):
            name = str(item.get("name"))
            tickers = item.get("tickers", [])
            mapping[name] = [str(ticker) for ticker in tickers if str(ticker)]
        elif hasattr(item, "name") and hasattr(item, "tickers"):
            name = str(getattr(item, "name"))
            tickers = getattr(item, "tickers")
            mapping[name] = [str(ticker) for ticker in tickers if str(ticker)]
        else:
            raise TypeError("Unsupported risk budget specification.")

    return mapping if mapping else None


def _risk_by_budget(
    latest_contribution: pd.Series,
    budgets: Mapping[str, Sequence[str]],
) -> pd.Series:
    """Aggregate asset-level risk contributions into budget buckets."""

    totals: dict[str, float] = {}
    assigned_assets: set[str] = set()

    for name, tickers in budgets.items():
        relevant = [ticker for ticker in tickers if ticker in latest_contribution.index]
        if not relevant:
            continue
        totals[name] = float(latest_contribution.loc[relevant].sum())
        assigned_assets.update(relevant)

    remainder = latest_contribution.drop(labels=list(assigned_assets), errors="ignore")
    if not remainder.empty:
        totals["Unallocated"] = float(remainder.sum())

    if not totals:
        return pd.Series(dtype=float)

    return pd.Series(totals, dtype=float).sort_values(ascending=False)


def _build_auto_tearsheet_figures(
    *,
    returns: pd.DataFrame | None,
    drawdowns: pd.DataFrame | None,
    risk_contribution: RiskContributionResult | None,
    risk_budgets: Mapping[str, Sequence[str]] | None,
    cost_breakdown: pd.Series | pd.DataFrame | None,
    existing_titles: set[str] | None = None,
) -> list[tuple[str, plt.Figure]]:
    """Create standard tear sheet figures when the required data is available."""

    figures: list[tuple[str, plt.Figure]] = []
    titles = existing_titles or set()

    if returns is not None and "Cumulative NAV" not in titles:
        try:
            ax_nav = plot_cumulative_returns(returns, title="Cumulative NAV")
            ax_nav.set_ylabel("NAV")
            figures.append(("Cumulative NAV", ax_nav.figure))
        except Exception:
            pass

    dd_frame: pd.DataFrame | None = None
    if drawdowns is not None:
        dd_frame = drawdowns.copy()
    elif returns is not None:
        cumulative = (1.0 + returns).cumprod()
        peaks = cumulative.cummax()
        dd_frame = cumulative / peaks - 1.0

    if dd_frame is not None and not dd_frame.empty and "Drawdown" not in titles:
        try:
            ax_dd = plt.subplots(figsize=(8, 4))[1]
            for column in dd_frame.columns:
                ax_dd.fill_between(
                    dd_frame.index, dd_frame[column], 0, alpha=0.3, label=column
                )
            ax_dd.set_title("Drawdown")
            ax_dd.set_ylabel("Drawdown")
            ax_dd.set_xlabel("Date")
            ax_dd.legend(loc="best")
            ax_dd.grid(True, alpha=0.3)
            figures.append(("Drawdown", ax_dd.figure))
        except Exception:
            pass

    if (
        risk_contribution is not None
        and risk_contribution.percentage is not None
        and not risk_contribution.percentage.empty
        and risk_budgets is not None
        and "Risk Contribution by Budget" not in titles
    ):
        latest_index = risk_contribution.percentage.index[-1]
        latest_series = risk_contribution.percentage.loc[latest_index].dropna()
        aggregated = _risk_by_budget(latest_series, risk_budgets)
        if not aggregated.empty:
            try:
                fig_rc, ax_rc = plt.subplots(figsize=(8, 4))
                ax_rc.bar(
                    aggregated.index.astype(str),
                    aggregated.values,
                    color=plt.cm.tab20.colors[: len(aggregated)],
                )
                ax_rc.set_title("Risk Contribution by Budget")
                ax_rc.set_ylabel("Share of portfolio risk")
                ax_rc.set_ylim(0, float(max(1.0, aggregated.values.max() * 1.05)))
                ax_rc.grid(True, axis="y", alpha=0.3)
                ax_rc.tick_params(axis="x", rotation=45)
                for label in ax_rc.get_xticklabels():
                    label.set_horizontalalignment("right")
                figures.append(("Risk Contribution by Budget", fig_rc))
            except Exception:
                pass

    if cost_breakdown is not None and "Cost Decomposition" not in titles:
        if isinstance(cost_breakdown, pd.DataFrame):
            series = (
                cost_breakdown.apply(pd.to_numeric, errors="coerce")
                .sum(axis=1)
                .dropna()
            )
        elif isinstance(cost_breakdown, pd.Series):
            series = cost_breakdown.apply(pd.to_numeric, errors="coerce").dropna()
        else:
            series = pd.Series(dtype=float)
        if not series.empty:
            try:
                series = series.sort_values(ascending=True)
                fig_cost, ax_cost = plt.subplots(figsize=(8, 4))
                ax_cost.barh(
                    series.index.astype(str), series.values, color="tab:orange"
                )
                ax_cost.set_title("Cost Decomposition")
                ax_cost.set_xlabel("Cost impact")
                ax_cost.grid(True, axis="x", alpha=0.3)
                figures.append(("Cost Decomposition", fig_cost))
            except Exception:
                pass

    return figures


def _ensure_frame(data: pd.Series | pd.DataFrame, name: str) -> pd.DataFrame:
    if isinstance(data, pd.DataFrame):
        frame = data.copy()
    elif isinstance(data, pd.Series):
        frame = data.to_frame(name=data.name or name)
    else:
        raise TypeError(f"{name} must be a pandas Series or DataFrame")
    frame = frame.apply(pd.to_numeric, errors="coerce").dropna(how="all")
    if frame.empty:
        raise ValueError(f"{name} is empty after dropping NaNs")
    return frame


def _build_nav_figure(data: AdvancedTearsheetData) -> tuple[str, plt.Figure] | None:
    if data.nav is not None:
        frame = _ensure_frame(data.nav, "nav")
        fig, ax = plt.subplots(figsize=(8, 4))
        for column in frame.columns:
            ax.plot(frame.index, frame[column], label=column)
        ax.set_title(data.nav_title)
        ax.set_ylabel("NAV")
        ax.set_xlabel("Date")
        ax.legend(loc="best")
        ax.grid(True, alpha=0.3)
        return data.nav_title, fig

    if data.returns is None:
        return None

    ax = plot_cumulative_returns(
        data.returns,
        benchmark=data.benchmark,
        title=data.nav_title,
    )
    return data.nav_title, ax.figure


def _build_drawdown_figure(
    data: AdvancedTearsheetData,
) -> tuple[str, plt.Figure] | None:
    returns: pd.Series | pd.DataFrame | None = data.returns

    if returns is None and data.nav is not None:
        nav_frame = _ensure_frame(data.nav, "nav")
        returns = nav_frame.pct_change().dropna(how="all")

    if returns is None:
        return None

    ax = plot_drawdown(returns, title=data.drawdown_title)
    return data.drawdown_title, ax.figure


def _aggregate_budget_contributions(
    percentage: pd.Series,
    budgets: Sequence[RiskBudget],
) -> pd.Series:
    contributions: dict[str, float] = {}
    accounted: set[str] = set()

    for budget in budgets:
        if not budget.tickers:
            continue
        values = percentage.reindex(budget.tickers).fillna(0.0)
        contributions[budget.name] = float(values.sum())
        accounted.update(
            ticker for ticker in budget.tickers if ticker in percentage.index
        )

    residual = float(percentage.drop(labels=list(accounted), errors="ignore").sum())
    if abs(residual) > 1e-8:
        contributions["Unallocated"] = residual

    series = pd.Series(contributions, dtype=float)
    if series.empty:
        return series
    series = series.sort_values(ascending=False)
    return series


def _build_budget_figure(
    data: AdvancedTearsheetData,
    risk_summary: RiskSummary | None,
) -> tuple[str, plt.Figure] | None:
    if not data.risk_budgets:
        return None
    if risk_summary is None or risk_summary.risk_contribution is None:
        return None

    percentage = risk_summary.risk_contribution.percentage
    if percentage.empty:
        return None

    latest = percentage.iloc[-1].dropna()
    aggregated = _aggregate_budget_contributions(latest, data.risk_budgets)
    if aggregated.empty:
        return None

    fig, ax = plt.subplots(figsize=(8, 4))
    colors = plt.cm.tab20.colors
    for idx, (label, value) in enumerate(aggregated.items()):
        ax.bar(label, value, color=colors[idx % len(colors)])

    ax.set_title(data.risk_budget_title)
    ax.set_ylabel("Risk Share")
    ax.set_xlabel("Budget")
    ax.axhline(0.0, color="black", linewidth=0.8)
    ax.grid(True, axis="y", alpha=0.3)
    ax.tick_params(axis="x", rotation=20)
    return data.risk_budget_title, fig


def _normalise_cost_series(
    cost_breakdown: pd.Series | pd.DataFrame | Mapping[str, float] | None
) -> pd.Series | None:
    if cost_breakdown is None:
        return None

    if isinstance(cost_breakdown, pd.Series):
        series = cost_breakdown.copy()
    elif isinstance(cost_breakdown, pd.DataFrame):
        if cost_breakdown.empty:
            return None
        if cost_breakdown.shape[1] == 1:
            series = cost_breakdown.iloc[:, 0]
        elif cost_breakdown.shape[0] == 1:
            series = cost_breakdown.iloc[0]
        else:
            series = cost_breakdown.sum(axis=0)
            if isinstance(series, pd.DataFrame):
                series = series.iloc[:, 0]
    elif isinstance(cost_breakdown, Mapping):
        series = pd.Series(dict(cost_breakdown), dtype=float)
    else:
        raise TypeError("cost_breakdown must be Series, DataFrame, or mapping")

    series = pd.to_numeric(series, errors="coerce").dropna()
    series = series[series != 0]
    if series.empty:
        return None
    return series.astype(float).sort_values(ascending=False)


def _build_cost_figure(
    data: AdvancedTearsheetData,
) -> tuple[str, plt.Figure] | None:
    series = _normalise_cost_series(data.cost_breakdown)
    if series is None:
        return None

    fig, ax = plt.subplots(figsize=(8, 4))
    ax.barh(series.index[::-1], series.values[::-1], color="#4B8BBE")
    ax.set_title(data.cost_title)
    ax.set_xlabel(data.cost_label)
    ax.set_ylabel("Component")
    ax.grid(True, axis="x", alpha=0.3)
    ax.tick_params(axis="y", labelsize=9)

    max_abs = float(series.abs().max())
    if max_abs > 0:
        padding = max_abs * 0.02
        for y, value in enumerate(series.values[::-1]):
            offset = padding if value >= 0 else -padding
            ha = "left" if value >= 0 else "right"
            ax.text(value + offset, y, f"{value:.4f}", va="center", ha=ha, fontsize=9)

    return data.cost_title, fig


def build_advanced_tearsheet_figures(
    data: AdvancedTearsheetData,
    risk_summary: RiskSummary | None,
) -> list[tuple[str, plt.Figure]]:
    """Generate standardised figures for the advanced tear sheet."""

    figures: list[tuple[str, plt.Figure]] = []

    nav_fig = _build_nav_figure(data)
    if nav_fig is not None:
        figures.append(nav_fig)

    drawdown_fig = _build_drawdown_figure(data)
    if drawdown_fig is not None:
        figures.append(drawdown_fig)

    budget_fig = _build_budget_figure(data, risk_summary)
    if budget_fig is not None:
        figures.append(budget_fig)

    cost_fig = _build_cost_figure(data)
    if cost_fig is not None:
        figures.append(cost_fig)

    return figures


def build_report_bundle(
    performance: pd.DataFrame,
    risk: RiskSummary | pd.DataFrame,
    figures: Iterable[FigureLike],
    metadata: dict[str, Any] | None = None,
    *,
    returns: pd.Series | pd.DataFrame | None = None,
    benchmark: pd.Series | pd.DataFrame | None = None,
    risk_budgets: Mapping[str, Sequence[str]] | Sequence[Any] | None = None,
    cost_breakdown: pd.Series | pd.DataFrame | None = None,
    auto_tearsheet: bool = True,
) -> ReportBundle:
    """Aggregate raw pieces into a :class:`ReportBundle`."""

    if not isinstance(performance, pd.DataFrame):
        raise TypeError("performance must be a DataFrame")

    risk_contribution_result: RiskContributionResult | None = None

    if isinstance(risk, RiskSummary):
        risk_table = risk.metrics
        drawdowns = risk.drawdowns
        risk_contribution_result = risk.risk_contribution
    elif isinstance(risk, pd.DataFrame):
        risk_table = risk
        drawdowns = None
    else:
        raise TypeError("risk must be RiskSummary or DataFrame")

    if not isinstance(risk_table, pd.DataFrame):
        raise TypeError("risk metrics must be a DataFrame")

    meta_copy = dict(metadata or {})

    returns_frame = _coerce_frame(returns, name="returns")
    if returns_frame is None:
        maybe_returns = meta_copy.get("returns")
        if isinstance(maybe_returns, (pd.Series, pd.DataFrame)):
            returns_frame = _coerce_frame(maybe_returns, name="returns")

    benchmark_frame = _coerce_frame(benchmark, name="benchmark")
    if benchmark_frame is None:
        maybe_benchmark = meta_copy.get("benchmark")
        if isinstance(maybe_benchmark, (pd.Series, pd.DataFrame)):
            benchmark_frame = _coerce_frame(maybe_benchmark, name="benchmark")

    risk_budgets_source = (
        risk_budgets if risk_budgets is not None else meta_copy.get("risk_budgets")
    )
    risk_budgets_mapping = _normalise_risk_budgets(risk_budgets_source)

    cost_input: pd.Series | pd.DataFrame | None = cost_breakdown
    if cost_input is None:
        maybe_cost = meta_copy.get("cost_breakdown")
        if isinstance(maybe_cost, (pd.Series, pd.DataFrame)):
            cost_input = maybe_cost
    if isinstance(cost_input, pd.Series):
        cost_frame = cost_input.to_frame(name=cost_input.name or "value")
    elif isinstance(cost_input, pd.DataFrame):
        cost_frame = cost_input.copy()
    else:
        cost_frame = None

    figure_list = _normalise_figures(figures)
    existing_titles = {title for title, _ in figure_list}

    if auto_tearsheet:
        auto_figures = _build_auto_tearsheet_figures(
            returns=returns_frame,
            drawdowns=drawdowns if isinstance(drawdowns, pd.DataFrame) else None,
            risk_contribution=risk_contribution_result,
            risk_budgets=risk_budgets_mapping,
            cost_breakdown=cost_frame,
            existing_titles=existing_titles,
        )
        figure_list.extend(auto_figures)

    return ReportBundle(
        performance=performance.copy(),
        risk=risk_table.copy(),
        drawdowns=(
            drawdowns.copy() if isinstance(drawdowns, pd.DataFrame) else drawdowns
        ),
        figures=figure_list,
        metadata=meta_copy,
        returns=(
            returns_frame.copy() if isinstance(returns_frame, pd.DataFrame) else None
        ),
        benchmark=(
            benchmark_frame.copy()
            if isinstance(benchmark_frame, pd.DataFrame)
            else None
        ),
        risk_contribution=risk_contribution_result,
        risk_budgets=risk_budgets_mapping,
        cost_breakdown=(
            cost_frame.copy() if isinstance(cost_frame, pd.DataFrame) else None
        ),
    )


def _figure_to_base64(figure: plt.Figure) -> str:
    buffer = BytesIO()
    figure.savefig(buffer, format="png", bbox_inches="tight")
    plt.close(figure)
    encoded = base64.b64encode(buffer.getvalue()).decode("ascii")
    return f"data:image/png;base64,{encoded}"


def render_html(bundle: ReportBundle, template_path: str | Path | None = None) -> str:
    """Render a minimal HTML report for the provided bundle."""

    meta_rows = "".join(
        f"<tr><th>{key}</th><td>{value}</td></tr>"
        for key, value in sorted(bundle.metadata.items())
    )
    metadata_html = f"<table class='meta'>{meta_rows}</table>" if meta_rows else ""

    perf_html = bundle.performance.to_html(classes=["metrics", "performance"], border=0)
    risk_html = bundle.risk.to_html(classes=["metrics", "risk"], border=0)

    drawdown_html = (
        bundle.drawdowns.to_html(classes=["metrics", "drawdowns"], border=0)
        if isinstance(bundle.drawdowns, pd.DataFrame)
        else ""
    )

    figure_html_blocks = []
    for title, figure in bundle.figures:
        img_src = _figure_to_base64(figure)
        figure_html_blocks.append(
            f"<div class='figure'><h3>{title}</h3><img src='{img_src}' alt='{title}'/></div>"
        )
    figures_html = "".join(figure_html_blocks)

    body = f"""
    <html>
      <head>
        <meta charset='utf-8'/>
        <style>
          body {{ font-family: Arial, sans-serif; margin: 24px; }}
          table.metrics {{ border-collapse: collapse; margin-bottom: 24px; }}
          table.metrics th, table.metrics td {{ border: 1px solid #ddd; padding: 6px 10px; }}
          table.meta th {{ text-align: left; padding-right: 12px; }}
          .figure {{ margin-bottom: 32px; }}
          .figure img {{ max-width: 100%; height: auto; border: 1px solid #ccc; }}
        </style>
      </head>
      <body>
        <h1>Strategy Evaluation Report</h1>
        {metadata_html}
        <h2>Performance Metrics</h2>
        {perf_html}
        <h2>Risk Metrics</h2>
        {risk_html}
        {f"<h2>Drawdowns</h2>{drawdown_html}" if drawdown_html else ""}
        <h2>Figures</h2>
        {figures_html}
      </body>
    </html>
    """

    if template_path is None:
        return body

    template_text = Path(template_path).read_text(encoding="utf-8")
    if "${content}" in template_text:
        return Template(template_text).substitute(content=body)
    return template_text.replace("{{content}}", body)


def export_pdf(html: str, output_path: str | Path, *, engine: str = "auto") -> Path:
    """Export HTML to PDF when possible, otherwise fall back to HTML."""

    output_path = Path(output_path)
    engine = engine.lower()

    def _try_weasyprint() -> Path | None:
        try:
            from weasyprint import HTML  # type: ignore
        except ImportError:
            return None
        HTML(string=html).write_pdf(str(output_path))
        return output_path

    if engine in {"auto", "weasyprint"}:
        pdf_path = _try_weasyprint()
        if pdf_path is not None:
            return pdf_path

    if engine == "auto":
        # Additional engines could be plugged here (wkhtmltopdf, etc.).
        pass

    fallback_path = output_path.with_suffix(".html")
    fallback_path.write_text(html, encoding="utf-8")
    return fallback_path


def _export_tables(
    bundle: ReportBundle, output_dir: Path, filename: str
) -> dict[str, Path]:
    """Persist key DataFrames to LaTeX and Markdown formats."""

    def _float_format(value: float) -> str:
        return "" if pd.isna(value) else f"{value:.4f}"

    tables: dict[str, pd.DataFrame] = {
        "performance": bundle.performance,
        "risk": bundle.risk,
    }
    if isinstance(bundle.drawdowns, pd.DataFrame):
        tables["drawdowns"] = bundle.drawdowns

    paths: dict[str, Path] = {}
    output_dir.mkdir(parents=True, exist_ok=True)

    for name, df in tables.items():
        if df.empty:
            continue

        df_export = df.copy()
        latex_path = output_dir / f"{filename}_{name}.tex"
        try:
            latex_text = df_export.to_latex(
                index=True,
                escape=False,
                multicolumn=isinstance(df_export.columns, pd.MultiIndex),
                multirow=isinstance(df_export.index, pd.MultiIndex),
                float_format=_float_format,
            )
            latex_path.write_text(latex_text, encoding="utf-8")
            paths[f"{name}_latex"] = latex_path
        except Exception:
            latex_path.unlink(missing_ok=True)

        md_path = output_dir / f"{filename}_{name}.md"
        try:
            markdown_text = df_export.to_markdown(
                index=True,
                tablefmt="pipe",
                floatfmt=".4f",
            )
            md_path.write_text(markdown_text, encoding="utf-8")
            paths[f"{name}_markdown"] = md_path
        except Exception:
            md_path.unlink(missing_ok=True)

    return paths


def build_and_export_report(
    performance: pd.DataFrame,
    risk: RiskSummary | pd.DataFrame,
    figures: Iterable[FigureLike],
    metadata: dict[str, Any] | None,
    output_dir: str | Path,
    *,
    filename: str = "evaluation_report",
    template_path: str | Path | None = None,
    advanced_tearsheet: AdvancedTearsheetData | None = None,
    returns: pd.Series | pd.DataFrame | None = None,
    benchmark: pd.Series | pd.DataFrame | None = None,
    risk_budgets: Mapping[str, Sequence[str]] | Sequence[Any] | None = None,
    cost_breakdown: pd.Series | pd.DataFrame | None = None,
    auto_tearsheet: bool = True,
) -> ReportArtifacts:
    """Create a :class:`ReportBundle`, write HTML, and attempt PDF export."""

    figure_list = list(figures)

    risk_summary = risk if isinstance(risk, RiskSummary) else None
    if advanced_tearsheet is not None:
        advanced_figures = build_advanced_tearsheet_figures(
            advanced_tearsheet, risk_summary
        )
        figure_list.extend(advanced_figures)

    bundle = build_report_bundle(
        performance,
        risk,
        figure_list,
        metadata,
        returns=returns,
        benchmark=benchmark,
        risk_budgets=risk_budgets,
        cost_breakdown=cost_breakdown,
        auto_tearsheet=auto_tearsheet,
    )
    html = render_html(bundle, template_path=template_path)

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    html_path = output_dir / f"{filename}.html"
    html_path.write_text(html, encoding="utf-8")

    pdf_path = export_pdf(html, output_dir / f"{filename}.pdf")

    table_paths = _export_tables(bundle, output_dir, filename)

    return ReportArtifacts(
        bundle=bundle,
        html_path=html_path,
        pdf_path=pdf_path,
        table_paths=table_paths,
    )


__all__ = [
    "ReportBundle",
    "ReportArtifacts",
    "AdvancedTearsheetData",
    "build_advanced_tearsheet_figures",
    "build_report_bundle",
    "render_html",
    "export_pdf",
    "build_and_export_report",
]
