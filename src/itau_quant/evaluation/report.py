"""Utilities that assemble performance reports from metrics and figures."""

from __future__ import annotations

import base64
from dataclasses import dataclass
from io import BytesIO
from pathlib import Path
from string import Template
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple, Union

import matplotlib.pyplot as plt
import pandas as pd

from .plots.tearsheet import TearsheetFigure
from .stats import RiskSummary


FigureLike = Union[plt.Figure, TearsheetFigure, Tuple[str, plt.Figure]]


@dataclass(frozen=True)
class ReportBundle:
    """Normalised container with all artefacts required to build a report."""

    performance: pd.DataFrame
    risk: pd.DataFrame
    drawdowns: Optional[pd.DataFrame]
    figures: List[Tuple[str, plt.Figure]]
    metadata: Dict[str, Any]


@dataclass(frozen=True)
class ReportArtifacts:
    """Files generated by :func:`build_and_export_report`."""

    bundle: ReportBundle
    html_path: Path
    pdf_path: Path


def _normalise_figures(figures: Iterable[FigureLike]) -> List[Tuple[str, plt.Figure]]:
    normalised: List[Tuple[str, plt.Figure]] = []

    for item in figures:
        if isinstance(item, TearsheetFigure):
            normalised.append((item.title, item.figure))
        elif isinstance(item, tuple) and len(item) == 2:
            title, figure = item
            if not isinstance(figure, plt.Figure):
                raise TypeError("Tuple entries must be (title, Figure)")
            normalised.append((str(title), figure))
        elif isinstance(item, plt.Figure):
            normalised.append(("Figure", item))
        else:
            raise TypeError("Unsupported figure format: %r" % (item,))
    return normalised


def build_report_bundle(
    performance: pd.DataFrame,
    risk: Union[RiskSummary, pd.DataFrame],
    figures: Iterable[FigureLike],
    metadata: Optional[Dict[str, Any]] = None,
) -> ReportBundle:
    """Aggregate raw pieces into a :class:`ReportBundle`."""

    if not isinstance(performance, pd.DataFrame):
        raise TypeError("performance must be a DataFrame")

    if isinstance(risk, RiskSummary):
        risk_table = risk.metrics
        drawdowns = risk.drawdowns
    elif isinstance(risk, pd.DataFrame):
        risk_table = risk
        drawdowns = None
    else:
        raise TypeError("risk must be RiskSummary or DataFrame")

    if not isinstance(risk_table, pd.DataFrame):
        raise TypeError("risk metrics must be a DataFrame")

    figure_list = _normalise_figures(figures)
    metadata = dict(metadata or {})

    return ReportBundle(
        performance=performance.copy(),
        risk=risk_table.copy(),
        drawdowns=drawdowns.copy() if isinstance(drawdowns, pd.DataFrame) else drawdowns,
        figures=figure_list,
        metadata=metadata,
    )


def _figure_to_base64(figure: plt.Figure) -> str:
    buffer = BytesIO()
    figure.savefig(buffer, format="png", bbox_inches="tight")
    encoded = base64.b64encode(buffer.getvalue()).decode("ascii")
    return f"data:image/png;base64,{encoded}"


def render_html(bundle: ReportBundle, template_path: Optional[Union[str, Path]] = None) -> str:
    """Render a minimal HTML report for the provided bundle."""

    meta_rows = "".join(
        f"<tr><th>{key}</th><td>{value}</td></tr>" for key, value in sorted(bundle.metadata.items())
    )
    metadata_html = f"<table class='meta'>{meta_rows}</table>" if meta_rows else ""

    perf_html = bundle.performance.to_html(classes=["metrics", "performance"], border=0)
    risk_html = bundle.risk.to_html(classes=["metrics", "risk"], border=0)

    drawdown_html = (
        bundle.drawdowns.to_html(classes=["metrics", "drawdowns"], border=0)
        if isinstance(bundle.drawdowns, pd.DataFrame)
        else ""
    )

    figure_html_blocks = []
    for title, figure in bundle.figures:
        img_src = _figure_to_base64(figure)
        figure_html_blocks.append(
            f"<div class='figure'><h3>{title}</h3><img src='{img_src}' alt='{title}'/></div>"
        )
    figures_html = "".join(figure_html_blocks)

    body = f"""
    <html>
      <head>
        <meta charset='utf-8'/>
        <style>
          body {{ font-family: Arial, sans-serif; margin: 24px; }}
          table.metrics {{ border-collapse: collapse; margin-bottom: 24px; }}
          table.metrics th, table.metrics td {{ border: 1px solid #ddd; padding: 6px 10px; }}
          table.meta th {{ text-align: left; padding-right: 12px; }}
          .figure {{ margin-bottom: 32px; }}
          .figure img {{ max-width: 100%; height: auto; border: 1px solid #ccc; }}
        </style>
      </head>
      <body>
        <h1>Strategy Evaluation Report</h1>
        {metadata_html}
        <h2>Performance Metrics</h2>
        {perf_html}
        <h2>Risk Metrics</h2>
        {risk_html}
        {f"<h2>Drawdowns</h2>{drawdown_html}" if drawdown_html else ""}
        <h2>Figures</h2>
        {figures_html}
      </body>
    </html>
    """

    if template_path is None:
        return body

    template_text = Path(template_path).read_text(encoding="utf-8")
    if "${content}" in template_text:
        return Template(template_text).substitute(content=body)
    return template_text.replace("{{content}}", body)


def export_pdf(html: str, output_path: Union[str, Path], *, engine: str = "auto") -> Path:
    """Export HTML to PDF when possible, otherwise fall back to HTML."""

    output_path = Path(output_path)
    engine = engine.lower()

    def _try_weasyprint() -> Optional[Path]:
        try:
            from weasyprint import HTML  # type: ignore
        except ImportError:
            return None
        HTML(string=html).write_pdf(str(output_path))
        return output_path

    if engine in {"auto", "weasyprint"}:
        pdf_path = _try_weasyprint()
        if pdf_path is not None:
            return pdf_path

    if engine == "auto":
        # Additional engines could be plugged here (wkhtmltopdf, etc.).
        pass

    fallback_path = output_path.with_suffix(".html")
    fallback_path.write_text(html, encoding="utf-8")
    return fallback_path


def build_and_export_report(
    performance: pd.DataFrame,
    risk: Union[RiskSummary, pd.DataFrame],
    figures: Iterable[FigureLike],
    metadata: Optional[Dict[str, Any]],
    output_dir: Union[str, Path],
    *,
    filename: str = "evaluation_report",
    template_path: Optional[Union[str, Path]] = None,
) -> ReportArtifacts:
    """Create a :class:`ReportBundle`, write HTML, and attempt PDF export."""

    bundle = build_report_bundle(performance, risk, figures, metadata)
    html = render_html(bundle, template_path=template_path)

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    html_path = output_dir / f"{filename}.html"
    html_path.write_text(html, encoding="utf-8")

    pdf_path = export_pdf(html, output_dir / f"{filename}.pdf")

    return ReportArtifacts(bundle=bundle, html_path=html_path, pdf_path=pdf_path)


__all__ = [
    "ReportBundle",
    "ReportArtifacts",
    "build_report_bundle",
    "render_html",
    "export_pdf",
    "build_and_export_report",
]
